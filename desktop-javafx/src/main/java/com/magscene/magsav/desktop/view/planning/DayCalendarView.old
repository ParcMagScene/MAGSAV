package com.magscene.magsav.desktop.view.planning;

import com.magscene.magsav.desktop.theme.ThemeManager;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;

/**
 * Vue calendaire jour - Style cohérent avec WeekCalendarView
 * Affiche les créneaux horaires pour une journée complète
 */
public class DayCalendarView extends VBox {
    
    // Configuration cohérente avec WeekCalendarView
    private static final int HOUR_HEIGHT = 50;
    private static final int TIME_COLUMN_WIDTH = 80;
    private static final int START_HOUR = 7;
    private static final int END_HOUR = 20;
    
    private LocalDate currentDate;
    private GridPane dayGrid;
    private final List<EventBlock> eventBlocks = new ArrayList<>();
    private BiConsumer<LocalDateTime, LocalDateTime> onTimeSlotSelected;
    
    // Propriétés pour la sélection
    private boolean isSelecting = false;
    private LocalDateTime selectionStart;
    private LocalDateTime selectionEnd;
    private Rectangle selectionRectangle;
    
    // Interface pour les callbacks
    public interface OnTimeSlotSelectedListener {
        void onTimeSlotSelected(LocalDateTime start, LocalDateTime end);
    }
    
    // Classe pour représenter les événements
    private static class EventBlock {
        final String title;
        final LocalDateTime startTime;
        final LocalDateTime endTime;
        final String category;
        final Rectangle rectangle;
        
        EventBlock(String title, LocalDateTime startTime, LocalDateTime endTime, String category) {
            this.title = title;
            this.startTime = startTime;
            this.endTime = endTime;
            this.category = category;
            this.rectangle = new Rectangle();
            this.rectangle.getStyleClass().addAll("event-block", "event-" + category);
        }
    }
            
            // Label de l'heure avec taille fixe
            Label hourLabel = new Label(startTime.format(DateTimeFormatter.ofPattern("HH:mm")));
            hourLabel.getStyleClass().add("hour-label");
            hourLabel.setPrefWidth(60);
            hourLabel.setMinWidth(60);
            hourLabel.setMaxWidth(60);
            hourLabel.setAlignment(Pos.CENTER_RIGHT);
            hourLabel.setStyle("-fx-text-fill: #8B91FF; -fx-font-size: 12px; -fx-padding: 5;");
            
            // Zone de contenu avec contraintes de taille
            Pane contentArea = new Pane();
            contentArea.getStyleClass().add("time-slot-content");
            contentArea.setStyle("-fx-background-color: #142240;");
            contentArea.setPrefHeight(HOUR_HEIGHT);
            contentArea.setMaxHeight(HOUR_HEIGHT);
            contentArea.setMinHeight(HOUR_HEIGHT);
            HBox.setHgrow(contentArea, Priority.ALWAYS);
            
            this.getChildren().addAll(hourLabel, contentArea);
            
            setupMouseHandlers();
        }
        
        private void setupMouseHandlers() {
            this.setOnMouseEntered(e -> {
                if (!selected) {
                    this.getStyleClass().add("time-slot-hover");
                }
            });
            
            this.setOnMouseExited(e -> {
                this.getStyleClass().remove("time-slot-hover");
            });
        }
        
        public LocalDateTime getStartDateTime() {
            return LocalDateTime.of(date, startTime);
        }
        
        public LocalDateTime getEndDateTime() {
            return getStartDateTime().plusHours(1);
        }
        
        public void setSelected(boolean selected) {
            this.selected = selected;
            if (selected) {
                this.getStyleClass().add("time-slot-selected");
            } else {
                this.getStyleClass().remove("time-slot-selected");
            }
        }
    }
    
    private static class EventBlock extends Region {
        private final String title;
        private final LocalDateTime startTime;
        private final LocalDateTime endTime;
        private final String category;
        
        public EventBlock(String title, LocalDateTime startTime, LocalDateTime endTime, String category) {
            this.title = title;
            this.startTime = startTime;
            this.endTime = endTime;
            this.category = category;
            
            this.getStyleClass().addAll("event-block", "event-" + category);
            
            // Couleurs selon la catégorie d'agenda - harmonisées avec WeekCalendarView
            String[] colors = getCategoryColors();
            String backgroundColor = colors[0];
            String borderColor = colors[1];
            String textColor = colors[2];
            
            // Style de base pour l'événement avec coins arrondis harmonieux
            setStyle("-fx-background-color: " + backgroundColor + "; " +
                    "-fx-background-radius: 8; " +
                    "-fx-border-color: " + borderColor + "; " +
                    "-fx-border-width: 1; " +
                    "-fx-border-radius: 8; " +
                    "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.3), 3, 0, 0, 1);");
            
            // Label du titre avec contraintes de taille
            Label titleLabel = new Label(title);
            titleLabel.getStyleClass().add("event-title");
            titleLabel.setWrapText(true);
            titleLabel.setMaxWidth(Double.MAX_VALUE);
            titleLabel.setStyle("-fx-text-fill: " + textColor + "; -fx-font-weight: bold; -fx-font-size: 10px;");
            
            // Temps avec contraintes de taille
            String timeText = startTime.format(DateTimeFormatter.ofPattern("HH:mm")) +
                             " - " + 
                             endTime.format(DateTimeFormatter.ofPattern("HH:mm"));
            Label timeLabel = new Label(timeText);
            timeLabel.getStyleClass().add("event-time");
            timeLabel.setWrapText(false);
            timeLabel.setMaxWidth(Double.MAX_VALUE);
            timeLabel.setStyle("-fx-text-fill: " + textColor + "; -fx-font-size: 9px;");
            
            VBox content = new VBox(1, titleLabel, timeLabel);
            content.setPadding(new Insets(2));
            content.setMaxWidth(Double.MAX_VALUE);
            this.getChildren().add(content);
            
            calculatePosition();
        }
        
        private void calculatePosition() {
            int startHour = startTime.getHour();
            int startMinute = startTime.getMinute();
            int endHour = endTime.getHour();
            int endMinute = endTime.getMinute();
            
            if (startHour < START_HOUR) startHour = START_HOUR;
            if (endHour > END_HOUR) endHour = END_HOUR;
            
            double startY = (startHour - START_HOUR) * HOUR_HEIGHT + (startMinute / 60.0) * HOUR_HEIGHT;
            double endY = (endHour - START_HOUR) * HOUR_HEIGHT + (endMinute / 60.0) * HOUR_HEIGHT;
            double height = Math.max(endY - startY, 30); // Hauteur minimale
            
            // CONTRAINTES STRICTES DE TAILLE - ne peut pas grandir
            this.setLayoutY(startY);
            this.setPrefHeight(height);
            this.setMaxHeight(height);
            this.setMinHeight(height); // Force la hauteur exacte
            
            // Largeur contrainte pour ne pas affecter les cellules
            this.setMaxWidth(Region.USE_PREF_SIZE);
            this.setMinWidth(30); // Largeur minimum pour rester lisible
        }
        
        private String[] getCategoryColors() {
            // Retourne [backgroundColor, borderColor, textColor] - harmonisé avec WeekCalendarView
            return switch (category.toLowerCase()) {
                case "principal" -> new String[]{"#142240", "#142240", "#142240"}; // Planning principal : fond et bordure #142240
                case "technician" -> new String[]{"#1e5631", "#4ade80", "#4ade80"}; // Vert sombre, bordure verte claire, texte vert
                case "vehicle" -> new String[]{"#1e3a5f", "#60a5fa", "#60a5fa"}; // Bleu sombre, bordure bleue claire, texte bleu
                case "maintenance" -> new String[]{"#5f1e1e", "#f87171", "#f87171"}; // Rouge sombre, bordure rouge claire, texte rouge
                case "external" -> new String[]{"#4a1e5f", "#c084fc", "#c084fc"}; // Violet sombre, bordure violette claire, texte violet
                default -> new String[]{"#142240", "#142240", "#142240"};
            };
        }
    }
    
    public DayCalendarView(LocalDate date) {
        this.currentDate = date;
        this.eventBlocks = new ArrayList<>();
        
        getStyleClass().add("day-calendar-view");
        this.setStyle("-fx-background-color: #142240; " +
                     "-fx-border-color: #142240; " +
                     "-fx-border-width: 2; " +
                     "-fx-border-radius: 8;");
        
        // Configurer pour prendre tout l'espace disponible
        this.setPrefWidth(Region.USE_COMPUTED_SIZE);
        this.setPrefHeight(Region.USE_COMPUTED_SIZE);
        this.setMaxWidth(Double.MAX_VALUE);
        this.setMaxHeight(Double.MAX_VALUE);
        
        // En-tête avec la date
        Label dateLabel = new Label(date.format(DateTimeFormatter.ofPattern("EEEE dd MMMM yyyy")));
        dateLabel.getStyleClass().add("day-header");
        dateLabel.setStyle("-fx-background-color: #142240; -fx-text-fill: #6B71F2; -fx-font-weight: bold; -fx-padding: 10;");
        
        // Container des heures sans scroll
        hoursContainer = new VBox();
        hoursContainer.getStyleClass().add("hours-container");
        hoursContainer.setStyle("-fx-background-color: #142240;");
        hoursContainer.setPrefWidth(Region.USE_COMPUTED_SIZE);
        hoursContainer.setPrefHeight(Region.USE_COMPUTED_SIZE);
        hoursContainer.setMaxWidth(Double.MAX_VALUE);
        hoursContainer.setMaxHeight(Double.MAX_VALUE);
        
        VBox.setVgrow(hoursContainer, Priority.ALWAYS);
        
        this.getChildren().addAll(dateLabel, hoursContainer);
        
        createTimeSlots();
    }
    
    private void createTimeSlots() {
        hoursContainer.getChildren().clear();
        hoursContainer.setSpacing(0); // Suppression de tout espacement
        
        for (int hour = START_HOUR; hour <= END_HOUR; hour++) {
            LocalTime time = LocalTime.of(hour, 0);
            TimeSlot timeSlot = new TimeSlot(currentDate, time);
            
            // Gérer les clics pour sélection de créneaux
            timeSlot.setOnMouseClicked(this::handleTimeSlotClick);
            
            // Style avec fond #142240 et bordure discrète
            timeSlot.setStyle("-fx-background-color: #142240; -fx-border-color: #2a3f5f; -fx-border-width: 0 0 1 0;");
            
            hoursContainer.getChildren().add(timeSlot);
        }
    }
    
    private void handleTimeSlotClick(MouseEvent event) {
        if (event.getSource() instanceof TimeSlot timeSlot) {
            LocalDateTime startTime = timeSlot.getStartDateTime();
            LocalDateTime endTime = timeSlot.getEndDateTime();
            
            if (onTimeSlotSelected != null) {
                onTimeSlotSelected.accept(startTime, endTime);
            }
        }
    }
    
    public void setCurrentDate(LocalDate date) {
        this.currentDate = date;
        createTimeSlots();
        refreshEvents();
    }
    
    public LocalDate getCurrentDate() {
        return currentDate;
    }
    
    public void addEvent(String title, LocalDateTime startTime, LocalDateTime endTime, String category) {
        // Vérifier si l'événement est pour ce jour
        if (!startTime.toLocalDate().equals(currentDate)) {
            return;
        }
        
        EventBlock eventBlock = new EventBlock(title, startTime, endTime, category);
        eventBlocks.add(eventBlock);
        
        // Ajouter l'événement à la zone de contenu appropriée
        addEventToTimeSlot(eventBlock, startTime);
    }
    
    private void addEventToTimeSlot(EventBlock eventBlock, LocalDateTime startTime) {
        // Rechercher le TimeSlot correspondant à l'heure de début
        for (javafx.scene.Node node : hoursContainer.getChildren()) {
            if (node instanceof TimeSlot timeSlot) {
                LocalTime slotTime = timeSlot.startTime;
                if (slotTime.getHour() == startTime.getHour()) {
                    // Ajouter l'événement à la zone de contenu
                    if (timeSlot.getChildren().size() > 1) {
                        Pane contentArea = (Pane) timeSlot.getChildren().get(1);
                        
                        // Gestion des événements multiples avec décalage horizontal
                        int existingEvents = contentArea.getChildren().size();
                        double horizontalOffset = 70 + (existingEvents * 5); // Décalage après l'heure + offset pour événements multiples
                        double eventWidth = Math.max(40, Math.min(200, contentArea.getWidth() - horizontalOffset - 20));
                        
                        eventBlock.setLayoutX(horizontalOffset);
                        
                        // CONTRAINTES STRICTES : largeur fixe qui ne peut pas affecter la taille du TimeSlot
                        eventBlock.setPrefWidth(eventWidth);
                        eventBlock.setMaxWidth(eventWidth);
                        eventBlock.setMinWidth(Math.min(40, eventWidth));
                        
                        contentArea.getChildren().add(eventBlock);
                        
                        // Ajuster UNIQUEMENT la largeur des événements sans affecter le conteneur
                        contentArea.widthProperty().addListener((obs, oldWidth, newWidth) -> {
                            double newEventWidth = Math.max(40, Math.min(200, newWidth.doubleValue() - horizontalOffset - 20));
                            eventBlock.setPrefWidth(newEventWidth);
                            eventBlock.setMaxWidth(newEventWidth);
                        });
                        
                        return;
                    }
                }
            }
        }
    }
    
    public void clearEvents() {
        eventBlocks.clear();
        
        // Supprimer tous les événements des TimeSlots
        for (javafx.scene.Node node : hoursContainer.getChildren()) {
            if (node instanceof TimeSlot timeSlot && timeSlot.getChildren().size() > 1) {
                Pane contentArea = (Pane) timeSlot.getChildren().get(1);
                contentArea.getChildren().clear();
            }
        }
    }
    
    private void refreshEvents() {
        clearEvents();
        // Ici on rechargerait les événements depuis la source de données
        // Pour l'instant, on ne fait que nettoyer
    }
    
    public void setOnTimeSlotSelected(BiConsumer<LocalDateTime, LocalDateTime> callback) {
        this.onTimeSlotSelected = callback;
    }
    
    // Méthodes utilitaires
    public void scrollToTime(LocalTime time) {
        if (time.getHour() >= START_HOUR && time.getHour() <= END_HOUR) {
            double position = (double)(time.getHour() - START_HOUR) / (END_HOUR - START_HOUR + 1);
            
            // Rechercher le ScrollPane parent
            ScrollPane scrollPane = findScrollPane();
            if (scrollPane != null) {
                scrollPane.setVvalue(position);
            }
        }
    }
    
    private ScrollPane findScrollPane() {
        javafx.scene.Node parent = this.getParent();
        while (parent != null) {
            if (parent instanceof ScrollPane) {
                return (ScrollPane) parent;
            }
            parent = parent.getParent();
        }
        return null;
    }
}
