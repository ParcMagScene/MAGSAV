package com.magsav.gui.categories;

import com.magsav.model.Category;
import com.magsav.repo.CategoryRepository;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.stage.Modality;
import javafx.stage.Stage;

import java.net.URL;
import java.util.List;
import java.util.Optional;
import java.util.ResourceBundle;

public class CategoriesController implements Initializable {

  private final CategoryRepository repo = new CategoryRepository();

  @FXML private TreeView<String> treeView;
  @FXML private TextField tfSearch;

  @Override
  public void initialize(URL location, ResourceBundle resources) {
    // Configuration de la TreeView
    setupTreeView();
    
    // Chargement initial des catégories
    refreshCategories();
  }
  
  private void setupTreeView() {
    // Configuration de la TreeView avec menu contextuel
    treeView.setContextMenu(createContextMenu());
    
    // Gestion de la sélection
    treeView.getSelectionModel().selectedItemProperty().addListener((obs, oldSelection, newSelection) -> {
      // Mettre à jour l'état des boutons selon la sélection
      updateButtonStates();
    });
  }
  
  private ContextMenu createContextMenu() {
    ContextMenu contextMenu = new ContextMenu();
    
    MenuItem addSubcategory = new MenuItem("➕ Ajouter sous-catégorie");
    addSubcategory.setOnAction(e -> onAddSubcategory());
    
    MenuItem edit = new MenuItem("Modifier");
    edit.setOnAction(e -> onEdit());
    
    MenuItem delete = new MenuItem("Supprimer");
    delete.setOnAction(e -> onDelete());
    
    contextMenu.getItems().addAll(addSubcategory, new SeparatorMenuItem(), edit, delete);
    
    // Mise à jour dynamique du menu selon la sélection
    contextMenu.setOnShowing(e -> updateContextMenu(contextMenu));
    
    return contextMenu;
  }
  
  private void updateContextMenu(ContextMenu contextMenu) {
    TreeItem<String> selectedItem = treeView.getSelectionModel().getSelectedItem();
    boolean hasSelection = selectedItem != null && selectedItem instanceof CategoryTreeItem;
    
    contextMenu.getItems().get(0).setDisable(!hasSelection); // Ajouter sous-catégorie
    contextMenu.getItems().get(2).setDisable(!hasSelection); // Modifier
    contextMenu.getItems().get(3).setDisable(!hasSelection); // Supprimer
  }
  
  private void updateButtonStates() {
    // Cette méthode peut être utilisée pour activer/désactiver les boutons de la toolbar
    // selon la sélection actuelle
  }

  private void refreshCategories() {
    try {
      List<Category> allCategories = repo.findAll();
      
      // Créer la racine invisible
      TreeItem<String> root = new TreeItem<>("Root");
      treeView.setRoot(root);
      
      // Séparer les catégories principales et les sous-catégories
      for (Category category : allCategories) {
        if (category.parentId() == null) {
          // C'est une catégorie principale
          CategoryTreeItem mainItem = new CategoryTreeItem(category);
          root.getChildren().add(mainItem);
          
          // Ajouter ses sous-catégories
          addSubcategoriesToParent(mainItem, allCategories);
        }
      }
      
      // Expand tous les nœuds pour voir la hiérarchie
      expandAllNodes(root);
      
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur lors du chargement des catégories: " + e.getMessage()).showAndWait();
    }
  }
  
  private void addSubcategoriesToParent(CategoryTreeItem parentItem, List<Category> allCategories) {
    long parentId = parentItem.getCategory().id();
    
    for (Category category : allCategories) {
      if (category.parentId() != null && category.parentId() == parentId) {
        CategoryTreeItem childItem = new CategoryTreeItem(category);
        parentItem.getChildren().add(childItem);
        
        // Récursion pour les sous-sous-catégories
        addSubcategoriesToParent(childItem, allCategories);
      }
    }
  }
  
  private void expandAllNodes(TreeItem<String> node) {
    if (node != null && !node.isLeaf()) {
      node.setExpanded(true);
      for (TreeItem<String> child : node.getChildren()) {
        expandAllNodes(child);
      }
    }
  }
        if (event.getClickCount() == 2 && !row.isEmpty()) {
          CategoryDisplay selectedCategory = row.getItem();
          // Ouvrir seulement pour les catégories principales (pas les sous-catégories)
          if (selectedCategory.getType().equals("Catégorie")) {
            openSubcategoriesWindow(selectedCategory);
          }
        }
      });
      return row;
    });
    
    // Chargement initial
    refreshCategories();
  }

  private void refreshCategories() {
    try {
      List<Category> categories = repo.findAllCategories();
      categoryItems.clear();
      
      for (Category cat : categories) {
        String type = cat.parentId() == null ? "Catégorie" : "Sous-catégorie";
        String parentName = "";
        String hierarchie = cat.nom();
        
        if (cat.parentId() != null) {
          // Trouver le nom du parent
          Category parent = categories.stream()
              .filter(c -> c.id() == cat.parentId())
              .findFirst()
              .orElse(null);
          if (parent != null) {
            parentName = parent.nom();
            hierarchie = parent.nom() + " > " + cat.nom();
          }
        }
        
        categoryItems.add(new CategoryDisplay(cat.id(), hierarchie, cat.nom(), type, parentName));
      }
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur lors du chargement des catégories: " + e.getMessage()).showAndWait();
    }
  }

  private void openSubcategoriesWindow(CategoryDisplay categoryDisplay) {
    try {
      // Récupérer la catégorie complète depuis la base
      Optional<Category> categoryOpt = repo.findById(categoryDisplay.getId());
      if (categoryOpt.isEmpty()) {
        new Alert(Alert.AlertType.ERROR, "Catégorie introuvable").showAndWait();
        return;
      }
      
      Category category = categoryOpt.get();
      
      FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/subcategories.fxml"));
      Parent root = loader.load();
      SubcategoriesController controller = loader.getController();
      controller.setParentCategory(category);

      Stage stage = new Stage();
      stage.setTitle("Sous-catégories de " + category.nom());
      stage.initModality(Modality.WINDOW_MODAL);
      stage.initOwner(table.getScene().getWindow());
      stage.setScene(new Scene(root));
      stage.setResizable(true);
      
      stage.setOnHidden(e -> {
        // Rafraîchir la liste principale quand la fenêtre se ferme
        refreshCategories();
      });
      
      stage.show();
      
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur: " + e.getMessage()).showAndWait();
    }
  }

  @FXML
  private void onAddCategory() {
    try {
      FXMLLoader l = new FXMLLoader(getClass().getResource("/fxml/categories/category_form.fxml"));
      Parent root = l.load();
      CategoryFormController ctl = l.getController();
      ctl.initForCategory();

      Dialog<ButtonType> d = new Dialog<>();
      d.setTitle("Ajouter une catégorie");
      d.getDialogPane().setContent(root);
      d.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
      Optional<ButtonType> res = d.showAndWait();
      if (res.isEmpty() || res.get() != ButtonType.OK) return;

      String name = ctl.name();
      if (name.length() < 2) { new Alert(Alert.AlertType.WARNING, "Nom requis (≥ 2 caractères)").showAndWait(); return; }

      long newCatId = repo.insertCategory(name);
      
      // Rafraîchir la liste
      refreshCategories();

      // Proposer d'ajouter une sous-catégorie
      Alert ask = new Alert(Alert.AlertType.CONFIRMATION, "Créer une sous-catégorie pour « " + name + " » maintenant ?", ButtonType.YES, ButtonType.NO);
      ask.setHeaderText(null);
      ask.showAndWait().filter(b -> b == ButtonType.YES).ifPresent(b -> onAddSubcategoryPrefilled(newCatId));
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur: " + e.getMessage()).showAndWait();
    }
  }

  @FXML
  private void onAddSubcategory() {
    onAddSubcategoryPrefilled(-1);
  }

  private void onAddSubcategoryPrefilled(long parentId) {
    try {
      FXMLLoader l = new FXMLLoader(getClass().getResource("/fxml/categories/category_form.fxml"));
      Parent root = l.load();
      CategoryFormController ctl = l.getController();
      var cats = repo.findAllCategories();
      Category preselect = cats.stream().filter(c -> c.id() == parentId).findFirst().orElse(null);
      ctl.initForSubcategory(cats, preselect);

      Dialog<ButtonType> d = new Dialog<>();
      d.setTitle("Ajouter une sous-catégorie");
      d.getDialogPane().setContent(root);
      d.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
      Optional<ButtonType> res = d.showAndWait();
      if (res.isEmpty() || res.get() != ButtonType.OK) return;

      String name = ctl.name();
      if (name.length() < 2) { new Alert(Alert.AlertType.WARNING, "Nom requis (≥ 2 caractères)").showAndWait(); return; }
      Category parent = ctl.parent();
      if (parent == null) { new Alert(Alert.AlertType.WARNING, "Sélectionner une catégorie parente").showAndWait(); return; }

      repo.insertSubcategory(parent.id(), name);
      
      // Rafraîchir la liste
      refreshCategories();
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur: " + e.getMessage()).showAndWait();
    }
  }

  @FXML
  private void onEdit() {
    // Récupérer la catégorie sélectionnée
    CategoryDisplay selected = table.getSelectionModel().getSelectedItem();
    if (selected == null) {
      new Alert(Alert.AlertType.WARNING, "Veuillez sélectionner une catégorie à modifier").showAndWait();
      return;
    }

    try {
      // Récupérer la catégorie complète depuis la base
      Optional<Category> categoryOpt = repo.findById(selected.getId());
      if (categoryOpt.isEmpty()) {
        new Alert(Alert.AlertType.ERROR, "Catégorie introuvable").showAndWait();
        return;
      }
      
      Category category = categoryOpt.get();
      
      FXMLLoader l = new FXMLLoader(getClass().getResource("/fxml/categories/category_form.fxml"));
      Parent root = l.load();
      CategoryFormController ctl = l.getController();
      
      // Initialiser le formulaire avec la catégorie actuelle
      var cats = repo.findAllCategories();
      ctl.init(cats, category);

      Dialog<ButtonType> d = new Dialog<>();
      d.setTitle("Modifier la catégorie");
      d.getDialogPane().setContent(root);
      d.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
      Optional<ButtonType> res = d.showAndWait();
      if (res.isEmpty() || res.get() != ButtonType.OK) return;

      String newName = ctl.name();
      if (newName.length() < 2) { 
        new Alert(Alert.AlertType.WARNING, "Nom requis (≥ 2 caractères)").showAndWait(); 
        return; 
      }

      // Créer la catégorie mise à jour
      Category parentCat = ctl.parent();
      Long newParentId = (parentCat != null) ? parentCat.id() : null;
      Category updatedCategory = new Category(category.id(), newName, newParentId);
      
      // Mettre à jour la catégorie
      repo.update(updatedCategory);
      
      new Alert(Alert.AlertType.INFORMATION, "Catégorie modifiée avec succès").showAndWait();
      refreshCategories();
      
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur: " + e.getMessage()).showAndWait();
    }
  }

  @FXML
  private void onDelete() {
    // Récupérer la catégorie sélectionnée
    CategoryDisplay selected = table.getSelectionModel().getSelectedItem();
    if (selected == null) {
      new Alert(Alert.AlertType.WARNING, "Veuillez sélectionner une catégorie à supprimer").showAndWait();
      return;
    }

    // Confirmation de suppression
    Alert confirmation = new Alert(Alert.AlertType.CONFIRMATION);
    confirmation.setTitle("Confirmer la suppression");
    confirmation.setHeaderText("Supprimer la catégorie « " + selected.getNom() + " » ?");
    
    String message = "Cette action supprimera définitivement la catégorie";
    if (selected.getType().equals("Catégorie")) {
      message += " et toutes ses sous-catégories";
    }
    message += ".\n\nCette action ne peut pas être annulée.";
    
    confirmation.setContentText(message);
    confirmation.getButtonTypes().setAll(ButtonType.YES, ButtonType.NO);

    Optional<ButtonType> result = confirmation.showAndWait();
    if (result.isEmpty() || result.get() != ButtonType.YES) {
      return;
    }

    // Supprimer la catégorie
    try {
      boolean success = repo.delete(selected.getId());
      if (success) {
        new Alert(Alert.AlertType.INFORMATION, "Catégorie supprimée avec succès").showAndWait();
        refreshCategories();
      } else {
        new Alert(Alert.AlertType.ERROR, "Aucune catégorie n'a été supprimée").showAndWait();
      }
    } catch (Exception e) {
      new Alert(Alert.AlertType.ERROR, "Erreur lors de la suppression: " + e.getMessage()).showAndWait();
    }
  }
}